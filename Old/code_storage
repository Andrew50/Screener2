

NOT REALLY OLD FLAG ------------------------------------------------------------------
def Flag(df,currentday, tf, ticker, path):

		
		lmax = 100
		lmin = 7
		mal = 5

		upper_stdev_filter = 1.5
		lower_stdev_filter = .75
		upper_stdev_filter2 = 1.5

		lower_stdev_filter2 = 1
		mal2 = 2
		coef = 0.01
		swings = np.empty([0,3])
		slope = 0
		prevma = []
		end = False
		def MA(df,i,l):
			ma = []
			for j in range(l):
				ma.append(df.iat[i-j,3])
				return statistics.mean(ma)
		ma = MA(df,currentday - 1,mal)
		i = 2
		while True:
			prevma = MA(df,currentday - i,mal)
			if slope == 1 and ma < prevma:
				slope = -1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,0]],axis = 0)
				if end:
					break
			elif slope == -1 and ma > prevma:
				slope = 1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,1]],axis = 0)
				if end:
					break
			elif slope == 0:
				if ma > prevma:
					slope = 1
				else:
					slope = -1

			if i >= lmax:
				end = True
			ma = prevma
			i += 1

		lval = 0
		l = 0


		for i in range(len(swings)-1):


			val = abs(swings[i,0]/swings[i+1,0] - 1) * (1 - coef * swings[i,1])
			if val > lval:
				lval = val
				move_size = abs(swings[i,0] - swings[i+1,0])
				l = swings[i,1] + int(mal/2)
		slope = 0
		swings = np.empty([0,3])
		ma = MA(df,currentday - 1,mal)
		i = 2
		end = False
		while True:
	
			prevma = MA(df,currentday - i,mal2)
			if slope == 1 and ma < prevma:
				slope = -1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,0]],axis = 0)
				add = df.iat[currentday-i,2]
				swings = np.append(swings,[[add,i,0]],axis = 0)
				if end:
					break
			elif slope == -1 and ma > prevma:
				slope = 1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,1]],axis = 0)
				add = df.iat[currentday-i,1]
				swings = np.append(swings,[[add,i,1]],axis = 0)
				if end:
					break
			elif slope == 0:
				if ma > prevma:
					slope = 1
				else:
					slope = -1
			if i >= lmax:
				end = True
			ma = prevma
			i += 1
		if l >= lmin and l < lmax:
			i = 0
			while True:
				if swings[i,1] > l:
					swings = swings[0:i]
					break
				i += 1
			n = len(swings)
			xh = np.empty([0,1])
			yh = np.empty(0)
			xl = np.empty([0,1])
			yl = np.empty(0)
			all_swings = []
			for i in range(n):
				high = swings[i,2]
				if high == 1:
					xh = np.append(xh,[[swings[i,1]]],axis = 0)
					yh = np.append(yh,swings[i,0])
				else:
					xl = np.append(xl,[[swings[i,1]]],axis = 0)
					yl = np.append(yl,swings[i,0])
				all_swings.append(swings[i,0])
			stdev = np.std(yl)
			mean = np.mean(yl)
			x = np.empty(0)
			y = np.empty(0)
			for i in range(len(yl) -1,-1,-1):
				z = (yl[i] - mean)/stdev
				if z < -upper_stdev_filter2 or z > lower_stdev_filter2:
					yl = np.delete(yl,i)
					xl = np.delete(xl,i,axis = 0)
			stdev = np.std(yh)
			mean = np.mean(yh)
			x = np.empty(0)
			y = np.empty(0)
			for i in range(len(yh) -1,-1,-1):
				z = (yh[i] - mean)/stdev
				if z > upper_stdev_filter or z < -lower_stdev_filter:
					yh = np.delete(yh,i)
					xh = np.delete(xh,i,axis = 0)
			modelh = LinearRegression().fit(xh, yh)
			bh = modelh.intercept_
			mh = modelh.coef_
			modell = LinearRegression().fit(xl, yl)
			bl = modell.intercept_
			ml = modell.coef_

			#calc traits
			tightening = mh - ml
			tightness = bh - bl
			higher_lows = -ml
			z = move_size / tightness
			atr= []
			adr_l = int(l)
			for j in range(adr_l): 
				high = df.iat[currentday-j-1,1]
				low = df.iat[currentday-j-1,2]
				val = (high - low ) 
				atr.append(val)
			atr = statistics.mean(atr)  
			oc = (df.iat[currentday - 1,0] + df.iat[currentday - 1,3])/2
			avg_slope = ((abs(ml) + abs(mh))/2)
			high = df.iat[currentday,1]
			low = df.iat[currentday,2]
			prev_close =df.iat[currentday-1,3]
			if (bh > bl and 
			z >3  and
			bh + mh*l > bl + ml*l 
			and oc < bh): 
				if prev_close < bh and prev_close > bl:
					val = avg_slope / atr
					if val < .1:
						val2 = tightening/atr
						if val2 > 0:
							log.log(df,currentday, tf, ticker, z, path, 'Flag')  


WEEKLY FLAG --------------------------------------------------------------------------


	def weeklyFlag(df,currentday, tf, ticker, path):
		pmPrice = df.iat[currentday,0]
		
		zfilter = 5
		z2filter = -100
		lmin = 20
		lmax = 50
		rsil = 20
		zl = 20
		rsi_filter = 30
		

		
			
			
		rsimax = 0
		for j in range(lmax):
				
			gains = []
			losses = []
					
					
			for k in range(rsil):
				change = (df.iat[currentday-k-j-1,3]/df.iat[currentday-k-j-2,3]) - 1
				if change > 0:
					gains.append(change)
				else:
					losses.append(-change)


			RS = (sum(gains)/rsil) / (sum(losses)/rsil)
			rsi = abs((100 - (100 / (1 + RS))) - 50)
			   
			if rsi > rsimax:
				rsimax = rsi
				l = j - 1
				
		  
				
		gaindata = []
		flagdata = []
			
		halfdata = []
				
		if l > lmin and l < lmax - 2 and rsimax > rsi_filter:
			for j in range(l * 2):
				ma3 = []
				for k in range(3):

					ma3.append(df.iat[currentday-j-k-1,3])
				ma3 = statistics.mean(ma3)
						  
				if j < int(l/2):
					halfdata.append(ma3)

				if j >=l:
					gaindata.append(ma3)
				else:

					flagdata.append(ma3)
					
			gain = max(gaindata) - min(gaindata)
			flag = max(flagdata) - min(flagdata)
			   
			halfflag = max(halfdata) - min(halfdata) 

			value = gain - flag
				

			zdata = []
			
			for i in range(zl):
				pushvalue = df.iat[currentday-i-1,1] - df.iat[currentday-i-1,2]
				zdata.append(pushvalue)

			z = (value - statistics.mean(zdata))/statistics.stdev(zdata)
			z2 =  -((halfflag - statistics.mean(zdata))/statistics.stdev(zdata))
			 
			if z > zfilter and z2 > z2filter:
					
				log.log(df,currentday, tf, ticker, z, path, 'WWFlg')  

OLD PIVOT -------------------------------------------------------------------------------------------------------------------------------------------------------------------


       
        lowergapzfilter = 1.5
        lowergapzfilter2 = 1.5

        pmPrice = df.iat[currentday,0]
       
        
        prevClose = df.iat[currentday-1,3]
        zgaps = []
        for i in range(15):
            n = 14-i
            gapvalue = abs((df.iat[currentday-n-1,0]/df.iat[currentday-n-2,3]) - 1)
            zgaps.append(gapvalue)
            
        todayGapValue = (pmPrice/prevClose)-1
        gapz = (abs(todayGapValue)-statistics.mean(zgaps))/statistics.stdev(zgaps)
        lastCloses = 0
        for c in range(4): 
            lastCloses = lastCloses + df.iat[currentday-c-1,3]
                
        ma3 = (lastCloses/4)
        close1 = df.iat[currentday-1,3]
        close2 = df.iat[currentday-2,3]
        open1 = df.iat[currentday-1,0]
        open2 = df.iat[currentday-2,0]
        low1 = df.iat[currentday-1,2]
        high1 = df.iat[currentday-1,1]
        z = gapz

         if gapz > lowergapzfilter and close1 < ma3  and close1 < close2 and close2 < open2 and close1 < open1 and open1 < close2 and pmPrice > high1 :
                
                
           log.log(df,currentday, tf, ticker, z, path, 'Pivot')   

        if gapz > lowergapzfilter2 and close1 > ma3  and close1 > close2 and close2 > open2 and close1 > open1 and open1 > close2 and pmPrice < low1:

            log.log(df,currentday, tf, ticker, z, path, 'Pivot') 




OLD FLAG DETECTION---------------------------------------------------------------------------------------------------------------------------------------------------------

pmPrice = df.iat[currentday,0]
       
        
        #if test:
           # zfilter = 4
       # else:
        zfilter = 8


        z2filter = .25
        lmin = 5
        lmax = 20
        rsil = 20
        zl = 20
        rsi_filter = 25
        todayl = 0
        currentvalue = 0

       
            
        rsimax = 0
        for j in range(lmax):
                
            gains = []
            losses = []
                    
                    
            for k in range(rsil):
                
                change = (df.iat[currentday-k-j-1,3]/df.iat[currentday-k-j-2,3]) - 1
                
                    
                if change > 0:
                    gains.append(change)
                else:
                    losses.append(-change)


            RS = (sum(gains)/rsil) / (sum(losses)/rsil)
            rsi = abs((100 - (100 / (1 + RS))) - 50)
               
            if rsi > rsimax:
                rsimax = rsi
                l = j - 1
                
          
                
        gaindata = []
        flagdata = []
            
        halfdata = []
                
        if l > lmin and l < lmax - 2 and rsimax > rsi_filter:
            for j in range(l * 2):
                ma3 = []
                for k in range(3):

                    ma3.append(df.iat[currentday-j-k-1,3])
                ma3 = statistics.mean(ma3)
                          
                if j < int(l/2):
                    halfdata.append(ma3)

                if j >=l:
                    gaindata.append(ma3)
                else:

                    flagdata.append(ma3)
                    
            gain = max(gaindata) - min(gaindata)
            flag = max(flagdata) - min(flagdata)
               
            halfflag = max(halfdata) - min(halfdata) 

            value = gain - flag
                

            zdata = []
            
            for i in range(zl):
                pushvalue = df.iat[currentday-i-1,1] - df.iat[currentday-i-1,2]
                zdata.append(pushvalue)

            z = (value - statistics.mean(zdata))/statistics.stdev(zdata)
            z2 =  -((halfflag - statistics.mean(zdata))/statistics.stdev(zdata))
             
            
            if z > zfilter and z2 > z2filter:
                    
                log.log(df,currentday, tf, ticker, z, path, 'Flag')  

OLD Prgoress-----------------------------------------------------------------------------------------------------------


def progress(size = None):
        
        if size == None:
            f = open('progress.txt','r')
            read = f.readlines()
            
            size = int(read[0])
            num = int(read[1])
            
            num += 1 

            f = open('progress.txt','w')
            f.writelines(str(f'{size} \n {num}') )

            
            p = round((num / size)*100 , 3)
            print(f'{p}%' , end='\r')
        else:
            f = open('progress.txt','w')
            f.writelines(str(f'{size} \n 0') )

OLD IDSCORD MESSAGE MAKER --------------------------------------------------------------------------------------------------------------------------------

#Log.sendDiscordEmbedIntraday(ticker + f" Open of 1m:{openCandlePrice} >> Current: {currPrice} ▲ {changePrice} ({change}%)", f"Intraday % Gaining Setup, Volume: {volume}, RelVol: {relativeVolAtTime}x, MCap: ${marketCapText}B")
        
        
        #discordintraday.post(file={"test": open('C:\Screener\tmp\test.png', "rb")})

        if False:
            openCandlePrice = float(setup_df.iloc[len(setup_df)-1][1])
            changePrice = round(float(currPrice - openCandlePrice), 2)
            change = round(screenbar["Change 1m, %"], 2)
            dayChange = round(screenbar['Change %'], 2)
            #changeFromOpen = round(screenbar['Change from Open'], 2)
            #openValue = screenbar['Open']
            currPrice = screenbar['Price']
            volume = screenbar['Volume']
            tick = screenbar['Ticker']
            pmChange = screenbar['Pre-market Change']
            currPrice = screenbar['Price']
            volume = screenbar['Volume']
            dolVol = screenbar['Volume*Price']
            marketCap = round(screenbar['Market Capitalization'], 1)
            marketCapText = round((marketCap / 1000000000), 2)
            relativeVolAtTime = round(screenbar['Relative Volume at Time'], 1)
            gapValuePercent = 0
            prevClose = 0
            pmPrice = 0
            prevClose = currPrice
            pmPrice = round((prevClose + pmChange), 2)
            gapValuePercent = round(((pmPrice/prevClose) - 1)*100, 2)
            lengthDf = len(setup_df)
            setup_df = setup_df[lengthDf - 80:]

        if(type == "Pop") and False:
            openCandlePrice = float(setup_df.iloc[len(setup_df)-1][1])
            changePrice = round(float(currPrice - openCandlePrice), 2)
            mpf.plot(setup_df, type='candle', mav=(10, 20), volume=True, title=tick, style=s, savefig=ourpath)
            log.sendDiscordEmbedIntraday(tick + f" Open of 1m:{openCandlePrice} >> Current: {currPrice} ▲ {changePrice} ({change}%)", f"Intraday % Gaining Setup, Volume: {volume}, RelVol: {relativeVolAtTime}x, MCap: ${marketCapText}B")
            log.sendDiscordIntradayPost('tmp/test.png')

        if(type == "Gainer") and False:
            openCandlePrice = float(setup_df.iloc[len(setup_df)-1][1])
            changePrice = round(float(currPrice - openCandlePrice), 2)
            mpf.plot(setup_df, type='candle', mav=(10, 20), volume=True, title=tick, style=s, savefig=ourpath)
            log.sendDiscordEmbedGainers(tick + f" PC:{prevClose} >> {currPrice} ▲ {currPrice} ({dayChange}%)", f"Top Gainer, Volume: {volume}, RelVol: {relativeVolAtTime}x, MCap: ${marketCapText}B")
            log.sendDiscordGainersPost('tmp/test.png')


OLDFINDEX -------------------------------------------
def findexold(df,dt):
        
        try:

            #if not type(dt) == datetime.date:
         #      dt = dt.date()

            x = (df.iloc[-1]['datetime'].date() - df.iloc[0]['datetime'].date()).days

            y = len(df)
            halfdate = df.iloc[int(y/2)]['datetime'].date()
            slope = y/x


            delta = (dt - halfdate).days + x/2
            

            print(delta)

            correction = 1.02
            estimate = int(correction*(delta*slope))

            i = estimate
            if i > y - 1:
                i = y - 1

           
            print(df.iloc[i]['datetime'].date())
            print( ((df.iloc[i]['datetime'].date() - dt).days)/x)

            k = 0

            

            while df.iloc[i]['datetime'].date() < dt:
                i += 1
                k += 1



            while True:

                if df.iloc[i]['datetime'].date() > dt:
                    i -= 1
                   
                else:
                    if df.iloc[i]['datetime'].time() > df.iloc[i-1]['datetime'].time():
                        i -= 1
                        
                    else:
                        break

            
         

            return i

        except TimeoutError:
            pass

       
   
    #print(df)
        #for i in range(len(df)):
            #print(f"{datetime} , {df.index[i]}")
            #if datetime < df.index[i]:
               # return i - 1 







MOVER--------------------------------------------------------------------------------------------


    def Mover(data_daily, currentday,pmPrice,screenbar, dateToSearch):
      

        zfilter = 3
        l2 = 10
        l = 100 
        q = deque([])
        z = []
        try: 
            prevClose = data_daily.iloc[currentday-1][4]
            for i in range(l + l2):
                n = l-i - 1
                q.append(data_daily.iloc[currentday-1][4])
                if len(q) >= l2:
                    ma1 = statistics.mean(q)
                    
                    if i >= l2:
                        value = abs(ma2/ma1 - 1)
                        z.append(value)
                    
                    ma2 = ma1
                    q.popleft()
            z = (value - statistics.mean(z))/statistics.stdev(z)
            if z > zfilter:
                
                
                log.daily(screenbar,z,"Mover", dateToSearch,pmPrice) 
           
        except IndexError:
           print(f" did not exist at the date " )
        except TimeoutError:
            print("Timeout caught")
        except FileNotFoundError:
            print(" does not have a file")




SCREEN------------------------------------------------------------------------------------------------------------------

user = 'cs.benliu@gmail.com'
password = 'tltShort!1'
options = Options()
options.binary_location = r"C:\Program Files\Mozilla Firefox\firefox.exe"
user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko/20100101 Firefox/87.0'
FireFoxDriverPath = os.path.join(os.getcwd(), 'Drivers', 'geckodriver.exe')
FireFoxProfile = webdriver.FirefoxProfile()
FireFoxProfile.set_preference("General.useragent.override", user_agent)
browser = webdriver.Firefox(options=options, executable_path=FireFoxDriverPath)
browser.implicitly_wait(7)
browser.maximize_window()
url = "https://www.tradingview.com/screener/"
browser.get(url)
mc = mpf.make_marketcolors(up='g',down='r')
s  = mpf.make_mpf_style(marketcolors=mc)
time.sleep(2)
element_tab = browser.find_element(By.XPATH, '//div[@data-set="performance"]')
try:
    element_tab.click()
except ElementNotInteractableException:
    print('test')

time.sleep(0.5)

element_tab = browser.find_element(By.XPATH, '//div[@data-set="overview"]')
try:
    element_tab.click()
except ElementNotInteractableException:
    print('test')

#Logging into trading view
login_page = browser.find_element(By.XPATH, '//button[@aria-label="Open user menu"]')
login_page.click()
time.sleep(0.25)
login_page = browser.find_element(By.XPATH, '//button[@data-name="header-user-menu-sign-in"]')
login_page.click()
time.sleep(0.25)
login_page = browser.find_element(By.XPATH, '//span[@class="tv-signin-dialog__social tv-signin-dialog__toggle-email js-show-email"]')
login_page.click()
username = browser.find_element(By.XPATH, '//input[@name="username"]')
username.send_keys("cs.benliu@gmail.com")
time.sleep(0.5)
password = browser.find_element(By.XPATH, '//input[@name="password"]')
password.send_keys("tltShort!1")
time.sleep(0.5)
login_button = browser.find_element(By.XPATH, '//button[@class="tv-button tv-button--size_large tv-button--primary tv-button--loader"]')
login_button.click()
time.sleep(1)
print(f'Scraping {url}...')
time.sleep(10)
print('wait over')

try:

    #setting default scanner settings
    browser.find_element(By.XPATH, '//div[@data-name="screener-field-sets"]').click()
    time.sleep(0.1)
    browser.find_element(By.XPATH, '//div[@data-set="overview"]').click()

    #seting filters
    filter_tab = browser.find_element(By.XPATH, '//div[@class="tv-screener-sticky-header-wrapper__fields-button-wrap"]')
    try:
        filter_tab.click()
    except ElementNotInteractableException:
        print('test')
    time.sleep(0.5)
    #Setting up the TV screener parameters
    tab1 = browser.find_element(By.XPATH, '//label[@data-field="earnings_per_share_basic_ttm"]')
    tab2 = browser.find_element(By.XPATH, '//label[@data-field="number_of_employees"]')
    tab3 = browser.find_element(By.XPATH, '//label[@data-field="sector"]')
    tab4 = browser.find_element(By.XPATH, '//label[@data-field="Recommend.All"]')
    tab6 = browser.find_element(By.XPATH, '//label[@data-field="price_earnings_ttm"]')
    tab7 = browser.find_element(By.XPATH, '//label[@data-field="relative_volume_intraday.5"]')
    tab8 = browser.find_element(By.XPATH, '//label[@data-field="change.1"]')
    tab9 = browser.find_element(By.XPATH, '//label[@data-field="change.5"]')
    tab10 = browser.find_element(By.XPATH, '//label[@data-field="change_from_open"]')
    tab11 = browser.find_element(By.XPATH, '//label[@data-field="exchange"]')
    tab12 = browser.find_element(By.XPATH, '//label[@data-field="premarket_change_abs"]')
    tab13 = browser.find_element(By.XPATH, '//label[@data-field="open"]')
    tab14 = browser.find_element(By.XPATH, '//label[@data-field="change_from_open_abs"]')
    tab15 = browser.find_element(By.XPATH, '//label[@data-field="change_from_open"]')
    tab1.click()
    tab2.click()
    tab3.click()
    tab4.click()
    tab6.click()
    tab7.click()
    tab8.click()
    tab9.click()
    tab10.click()
    tab11.click()
    tab12.click()
    tab13.click()
    tab14.click()
    tab15.click()
    time.sleep(0.5) 
    browser.find_element(By.XPATH, '//div[@data-name="screener-filter-sets"]').click()
    time.sleep(0.25)
    browser.find_element(By.XPATH, '//span[@class="js-filter-set-name"]').click()
    time.sleep(0.25)
    sortRVol = browser.find_element(By.XPATH, '//div[@data-field="change.1"]')
    sortRVol.click()
    count = 0
    tv = TvDatafeed(username=user,password=password)
    listTickersBurst = []
    listTickersGainers = []
    counter = 0
    while(True):



old EP 
 data_daily = tv.get_hist(tick, exchange, n_bars=100) # get 20 past daily candles
                print(data_daily.head(1))
                length = len(data_daily)
                gaps = []
                pmPrice = data_daily.iloc[length-1][4] + pmChange
                prevClose = data_daily.iloc[length-1][4]
                todayGapValue = round(((pmPrice/prevClose)-1), 2)
                for j in range(20): 
                        gaps.append((data_daily.iloc[length-1-j][1]/data_daily.iloc[length-2-j][4])-1)

                z = (todayGapValue-statistics.mean(gaps))/statistics.stdev(gaps)

                if(z < -5):
                    z = round(z, 3)
                    ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                    todayGapValuePercent = todayGapValue*100;
                    mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, title=tick, hlines=dict(hlines=[pmPrice], linestyle="-."), style=s, savefig=ourpath)
                    sendDiscordEmbed(tick + f" {prevClose} >> {pmPrice} ▼ {pmChange} ({todayGapValuePercent}%)", f"NEP Setup, Z-Score: {z}")
                    discord.post(file={"test": open("tmp/test.png", "rb")})
                if(z > 5):
                    z = round(z, 3)
                    ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                    todayGapValuePercent = todayGapValue*100;
                    mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, title=tick, hlines=dict(hlines=[pmPrice], linestyle="-."), style=s, savefig=ourpath)
                    sendDiscordEmbed(tick + f" {prevClose} >> {pmPrice} ▲ {pmChange} ({todayGapValuePercent}%)", f"EP Setup, Z-Score: {z}")
                    discord.post(file={"test": open("tmp/test.png", "rb")})

                    else:
                try: 
                    data_daily_full = pd.read_csv(f"D:/Screener/data_csvs/{tick}_data.csv")
                    indexOfDay = findIndex(data_daily_full, dateToSearch)
                    data_daily = data_daily_full
                    if(indexOfDay != 99999):
                        data_daily = data_daily_full[(indexOfDay - leftBuffer):(indexOfDay + 50)]
                        data_daily['Datetime'] = pd.to_datetime(data_daily['datetime'])
                        data_daily = data_daily.set_index('Datetime')
                        length = len(data_daily)
                        gaps = []
                        data_daily = data_daily.drop(['datetime'], axis=1)
                        tdyOpen = data_daily.iloc[length-50][1]
                        prevClose = data_daily.iloc[length-51][4]
                        todayGapValue = round(((tdyOpen/prevClose)-1), 2)  
                        for j in range(20): 
                            gaps.append((data_daily.iloc[length-51-j][1]/data_daily.iloc[length-52-j][4])-1)
                        z = (todayGapValue-statistics.mean(gaps))/statistics.stdev(gaps)
                        if(z < -4):
                            z = round(z, 3)
                            ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                            todayGapValuePercent = todayGapValue*100;
                            mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, vlines=dict(vlines=[dateToSearch],linewidths=(1), alpha=0.25), title=tick, style=s, savefig=ourpath)
                            sendDiscordEmbed(tick, f"NEP Setup, Date: {dateToSearch}, Z-Score: {z}")
                            discord.post(file={"test": open("tmp/test.png", "rb")})
                        if(z > 4):
                            z = round(z, 3)
                            ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                            todayGapValuePercent = todayGapValue*100;
                            mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, vlines=dict(vlines=[dateToSearch],linewidths=(1), alpha=0.25), title=tick, style=s, savefig=ourpath)
                            sendDiscordEmbed(tick, f"EP Setup, Date: {dateToSearch}, Z-Score: {z}")
                            discord.post(file={"test": open("tmp/test.png", "rb")})  
                except IndexError:
                    print(tick + " did not exist at the date " + dateToSearch)
                except TimeoutError:
                    print("Timeout caught")
                except FileNotFoundError:
                    print(tick + " does not have a file")












# tv-data-table

    time.sleep(2)
    element_tab = browser.find_element(By.XPATH, '//div[@data-set="performance"]')
    try:
        element_tab.click()
    except ElementNotInteractableException:
        print('test')

    time.sleep(0.5)

    element_tab = browser.find_element(By.XPATH, '//div[@data-set="overview"]')
    try:
        element_tab.click()
    except ElementNotInteractableException:
        print('test')

    #Logging into trading view
    login_page = browser.find_element(By.XPATH, '//button[@aria-label="Open user menu"]')
    login_page.click()
    time.sleep(0.25)
    login_page = browser.find_element(By.XPATH, '//button[@data-name="header-user-menu-sign-in"]')
    login_page.click()
    time.sleep(0.25)
    login_page = browser.find_element(By.XPATH, '//span[@class="tv-signin-dialog__social tv-signin-dialog__toggle-email js-show-email"]')
    login_page.click()
    username = browser.find_element(By.XPATH, '//input[@name="username"]')
    username.send_keys("cs.benliu@gmail.com")
    time.sleep(0.5)
    password = browser.find_element(By.XPATH, '//input[@name="password"]')
    password.send_keys("tltShort!1")
    time.sleep(0.5)
    login_button = browser.find_element(By.XPATH, '//button[@class="tv-button tv-button--size_large tv-button--primary tv-button--loader"]')
    login_button.click()
    time.sleep(1)


     #Loop stocks in screen
    for i in range(numTickers):
        tick = str(screener_data.iloc[i]['Ticker'])
        exchange = str(screener_data.iloc[i]['Exchange'])
        data_minute = tv.get_hist(tick, exchange, interval=Interval.in_1_minute, n_bars=350) #get the most recent candle of pre market
        data_daily = tv.get_hist(tick, exchange, n_bars=21) # get 20 past daily candles
        data_daily_100 = tv.get_hist(tick, exchange, n_bars=70)
        length = len(data_daily)
        gaps = []
        todayGapValue = (data_daily.iloc[length-1][1]/data_daily.iloc[length-2][4])-1
        for i in range(length): 
            if i > 0:
                if i < 20: 
                    gaps.append((data_daily.iloc[i][1]/data_daily.iloc[i-1][4])-1)


        z = (todayGapValue-statistics.mean(gaps))/statistics.stdev(gaps)


        Z SCORE GAP CHECK ------------------------------------------------------------------------------------------

        # MR Check   
        if(dolVol > 1000000 and volume>150000 and currPrice > 2 and pmChange != 0 and math.isnan(pmChange) != True):
            data_daily = tv.get_hist(tick, exchange, n_bars=70) # get 20 past daily candles
            print(data_daily.head(1))
            length = len(data_daily)
            pmPrice = data_daily.iloc[length-1][4] + pmChange
            prevClose = data_daily.iloc[length-1][4]
            todayGapValue = round(((pmPrice/prevClose)-1), 2)
            data = [] # 15 length
            gaps = [] # 30 length
            changedata = [] # 30 length
            #creating data array
            val = 0
            for i in range(15): 
                num = 14-i 
                lastCloses = 0
                for c in range(4): 
                    lastCloses = lastCloses + data_daily.iloc[length-1-c-num][4]
                fourSMA = round((lastCloses/4), 2)
                if(num == 0):
                    value = (fourSMA/pmPrice)-1
                    data.append(value)
                    val = value
                else:
                    value = (fourSMA/data_daily.iloc[length-1-num][1])
                    data.append(value)
            #creating gaps and changedata array
            chng = 0
            gp = 0
            gpo1 = 0
            for k in range(30):
                n = 29-k 
                if(n == 0):
                    gap = abs((pmPrice/prevClose) - 1)
                    gp = gap
                    changedat = abs((data_daily.iloc[length-1][4]/data_daily.iloc[length-1][1]) - 1)
                    chng = changedat
                    gaps.append(gap)
                    changedata.append(changedat)
                else:
                    gap = abs((data_daily.iloc[length-n][1]/data_daily.iloc[length-1-n][4]) - 1)
                    changedat = abs((data_daily.iloc[length-1-n][4]/data_daily.iloc[length-1-n][1]) - 1)
                    changedata.append(changedat)
                    gaps.append(gap)
                if(n == 1):
                    gap = abs(data_daily.iloc[length-1][1]/data_daily.iloc[length-2][4])
                    gpo1 = (gap - statistics.mean(gaps))/statistics.mean(gaps)

            z = (val - statistics.mean(data))/statistics.stdev(data)
            changez = (chng - statistics.mean(changedata))/statistics.stdev(changedata)
            gapz = (gp - statistics.mean(gaps))/statistics.stdev(gaps)
            
            zfilter = 1
            gapzfilter0 = 8
            gapzfilter1 = 4
            changezfilter = 4
            print(f"z is = {z}, gapz is {gapz}")
            if (gpo1 < gapzfilter1 and gapz < gapzfilter0 and changez < changezfilter and z > zfilter and value > 0):
                z = round(z, 3)
                ourpath = pathlib.Path("D:/Screener/tvdatafeed/tmp") / "test.png"
                todayGapValuePercent = todayGapValue*100;
                mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, title=tick, hlines=dict(hlines=[pmPrice], linestyle="-."), style=s, savefig=ourpath)
                sendDiscordEmbed(tick + f" {prevClose} >> {pmPrice} ▲ {pmChange} ({todayGapValuePercent}%)", f"MR Setup, Z-Score: {z}")
                discord.post(file={"test": open("tmp/test.png", "rb")})


