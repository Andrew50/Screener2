




long ass CREATE --------------------------------------------------------------



import os
import numpy as np
import pandas as pd
from Data7 import Data as data

import numpy as np
from typing import Tuple
from tqdm import tqdm
from matplotlib import pyplot as plt

# NN imports
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, LSTM, Bidirectional, Dropout

# Imports for evaluating the network
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

EPOCHS = 50
BATCH_SIZE = 64
VALIDATION = 0.05
LEARN_RATE = 1e-3
MODEL_SAVE_NAME = 'model'
TRAIN_SPLIT = 1
FEAT_LENGTH = 50
FEAT_COLS = ['open', 'low', 'high', 'close']
TICKERS = ['TSLA', 'AAPL', 'MSFT', 'NVDA', 'GOOG', 'AMD']

class Create:
    def evaluate_training(model: Sequential,x_test: np.array,y_test: np.array):
        score = model.evaluate(x_test,y_test,verbose = 0,)
    
        pred = np.argmax(model.predict(x_test), axis = 1,)
        cm = confusion_matrix(y_true = y_test,y_pred = pred,)
        cm_scaled = cm/cm.astype(np.float).sum(axis = 0)
        unscaled = ConfusionMatrixDisplay(confusion_matrix = cm)
        unscaled.plot()
        unscaled.ax_.set_title('Unscaled confusion matrix')
        scaled = ConfusionMatrixDisplay(confusion_matrix = cm_scaled)
        scaled.plot()
        scaled.ax_.set_title('Scaled confusion matrix')
        plt.show()
        return

    def time_series(df: pd.DataFrame,
                    col: str,
                    name: str, sample_size) -> pd.DataFrame:
        return df.assign(**{
            f'{name}_t-{lag}': col.shift(lag)
            for lag in range(0, sample_size)
        })


    def get_lagged_returns(df: pd.DataFrame, sample_size) -> pd.DataFrame:

        #close = df.iat[-2,3]
        for col in FEAT_COLS:
            #return_col = df[col]/df[col].shift(1)-1
            return_col = df[col]/df['close'].shift(1)  -1
            #return_col = df[col].div(close) - 1
            df = Create.time_series(df, return_col, f'feat_{col}_ret', sample_size)
        return df

    def get_classification(df: pd.DataFrame,value) -> pd.DataFrame:
        df['classification'] = value
        return df

    def reshape_x(x: np.array) -> np.array:
        num_feats = x.shape[1]//FEAT_LENGTH
        x_reshaped = np.zeros((x.shape[0], FEAT_LENGTH, num_feats))
        for n in range(0, num_feats):
            x_reshaped[:, :, n] = x[:, n*FEAT_LENGTH:(n+1)*FEAT_LENGTH]
        return x_reshaped

    def nn_multi(bar):
        try:
            setups = bar

            ticker = setups[0]
            date = setups[1]
            value = setups[2]
            setup_type = [3]


            if 'EP' in setup_type:
                sample_size = 15

            elif setup_type == 'MR':
                sample_size = 10

            elif 'F' in setup_type:
                sample_size = 75

            else: #pivot
                sample_size = 15
        
           





            df = data.get(ticker)
            sample_size = 50
            index = data.findex(df,date)
            df2 = df[index-sample_size:index]

            o = df.iat[index,0]
            add = pd.DataFrame({
                'datetime':[date],
                'open':[o],
                'high':[o],
                'low':[o],
                'close':[o],
                'volume':[0]}).set_index('datetime')
            df2 = pd.concat([df2,add])
         
            df = df2

            df = Create.get_lagged_returns(df, sample_size)
            df = Create.get_classification(df,value)

            return df.replace([np.inf, -np.inf], np.nan).dropna()[[col for col in df.columns if 'feat_' in col] + ['classification']]
            
        except:
            pass


    def sample(setuptype,use,split):



        buffer = 2

        if setuptype == 'AF':
            f = pd.read_feather('C:/Screener/setups/database/F.feather').sort_values(by='date', ascending = False).reset_index(drop = True)
            nf = pd.read_feather('C:/Screener/setups/database/NF.feather').sort_values(by='date', ascending = False).reset_index(drop = True)

            nf = nf[nf['setup'] == 1]




            for i in range(len(nf)):
              
                dt = nf.iat[i,1]
                index = data.findex(f.set_index('date'),dt)
                try:
                    f.iat[index,2] = 1
                except:
                    pass

            allsetups = f
            #allsetups = pd.concat([f,nf]).sort_values(by='date', ascending = False).reset_index(drop = True)
        else:

            allsetups = pd.read_feather('C:/Screener/setups/database/' + setuptype + '.feather').sort_values(by='date', ascending = False).reset_index(drop = True)
        
        yes = []
        no = []
        req_no = []

        g = allsetups.groupby(pd.Grouper(key='ticker'))
        # groups to a list of dataframes with list comprehension
        dfs = [group for _,group in g]

       
      
        for df in dfs:
            df = df.reset_index(drop = True)
        
            rem = 0
            for i in range(len(df)):
                bar = df.iloc[i]
           #     ticker = bar[0]
              #  date = bar[1]
                setup = bar[2]
               
                if setup == 1:

                    
                    if df.iat[i-1,2] == 0:
                        for j in range(buffer):
                            try:
                                req_no.append(df.iloc[i - j - 1])
                            except:
                                pass

                    yes.append(bar)
                    rem = buffer
                else:
                    if rem > 0:
                        req_no.append(bar)
                        rem -= 1

                    else:
                        #needs to be fixes because if setup occurs it will ad to no and to no_req because it adds to no req on a 1
                        no.append(bar)
            
     #   yes = allsetups[allsetups['setup'] == 1]
      #  no = allsetups[allsetups['setup'] == 0]
        
        yes = pd.DataFrame(yes)
        print(f'{len(yes)} setups')
        no = pd.DataFrame(no)
        req_no = pd.DataFrame(req_no)
        length = ((len(yes) / use) - len(yes)) - len(req_no)

        use = length / len(no)

        if use > 1:
            use = 1
        if use < 0:
            use = 0

        no = no.sample(frac = use)
       
        allsetups = pd.concat([yes,no,req_no]).sample(frac = 1).reset_index(drop = True)
        
      


        '''

        if split:
            eighty = int(len(allsetups) * 0.8)
            setups = allsetups.loc[0:eighty].reset_index(drop = True)
            rest = allsetups.loc[eighty:].reset_index(drop = True)
            rest.to_feather('C:/Screener/setups/database/Testdata_' + setuptype + '.feather')
            TRAIN_SPLIT = 0.8
        else:
            setups = allsetups
            TRAIN_SPLIT = 1
        TRAIN_SPLIT = 1
        '''
        setups = allsetups
        return setups



    def get_nn_data(setuptype,use,split):
 
        setups = Create.sample(setuptype,use,split)
        
        arglist = []
        for i in range(len(setups)):
            bar = setups.iloc[i].tolist()
            bar.append(setuptype)
           
            arglist.append(bar)

        dfs = data.pool(Create.nn_multi,arglist)
        nn_values = pd.concat(dfs)
      
        nn_values = nn_values.values
      
        np.random.shuffle(nn_values)
        #if TRAIN_SPLIT == 1:
         #   split_idx = -1
       # else:
          #  split_idx = int(TRAIN_SPLIT*nn_values.shape[0])

        '''
        np.save('x_test', Create.reshape_x(nn_values))
        np.save('y_test', nn_values)
     
        np.save('x_train', Create.reshape_x(nn_values))
        np.save('y_train', nn_values)
        '''
        
        split_idx = 0
        np.save('x_test', Create.reshape_x(nn_values[split_idx:, :-1]))
        np.save('y_test', nn_values[split_idx:, -1])
        split_idx = -1
        np.save('x_train', Create.reshape_x(nn_values[0:split_idx, :-1]))
        np.save('y_train', nn_values[0:split_idx:, -1])
        
        return
   
    def load_data() -> Tuple[np.array, np.array, np.array, np.array]:
        return (np.load('x_train.npy'),np.load('y_train.npy'),np.load('x_test.npy'),np.load('y_test.npy'),)

    def get_model(x_train: np.array) -> Sequential:
 
        return Sequential([
            Bidirectional(
                LSTM(
                    64, 
                    input_shape = (x_train.shape[1], x_train.shape[2]),
                    return_sequences = True,
                ),
            ),
            Dropout(0.2),
            Bidirectional(LSTM(32)),
            Dense(3, activation = 'softmax'),
        ])


    def test_data(ticker,date,setup_type):

        bar = [ticker,date,1,setup_type]
        x = Create.nn_multi(bar).values
        x = Create.reshape_x(x[0:, :-1])

        return x
        '''
        df = data.get(ticker)
        index = data.findex(df,date)



        #god wtf is this
        
        if 'EP' in setup_type:
                sample_size = 15

        elif setup_type == 'MR':
            sample_size = 10

        elif 'F' in setup_type:
            sample_size = 40

        else: #pivot
            sample_size = 15
        
        sample_size = 20 # HARD CODE IS HERE ---------------------------------------------------------------------------------------

      #  if 'MR' in setup_type:
            


        df2 = df[index-sample_size:index]
        
        o = df.iat[index,0]
        add = pd.DataFrame({
            'datetime':[date],
            'open':[o],
            'high':[o],
            'low':[o],
            'close':[o],
            'volume':[0]}).set_index('datetime')
        df2 = pd.concat([df2,add])
      
        df = df2
        df = Create.get_lagged_returns(df, sample_size)
  
        df = Create.get_classification(df,0)
        df = (
        df
        .dropna()
        .reset_index(drop = True)
        )
        x = Create.reshape_x(
            df[[col for col in df.columns if 'feat_' in col] + ['classification']]
            .values[:, :-1]
        )
        return x
        '''
  
    
    def run(setuptype,keep,split = True):
        Create.get_nn_data(setuptype,keep,split)
        x_train, y_train, x_test, y_test = Create.load_data()
        model = Create.get_model(x_train)
        model.compile(loss = 'sparse_categorical_crossentropy',optimizer = Adam(learning_rate = LEARN_RATE),metrics = ['accuracy'])
        model.fit(x_train,y_train,epochs = EPOCHS,batch_size = BATCH_SIZE,validation_split = VALIDATION,)

        if split:

            pass
            Create.evaluate_training(model, x_test, y_test)
        model.save('C:/Screener/setups/models/model_' + setuptype)
      
'''
if __name__ == '__main__':
    setuptype = 'P'
    keep = .40
    Create.run(setuptype,keep,True)
''' 



    
    





OLD get data v7 -------------------------------------------------------------------------------------


def get(ticker = 'AAPL',tf = 'd',date = None,premarket = False):    
        path = Data.path


        current = Data.isToday(date)

        if tf == 'daily':
            tf = 'd'
        if tf == 'minute':
            tf = '1min'

        if tf == 'd' or tf == 'w' or tf == 'm':
            df = feather.read_feather(r"" + path + "/daily/" + ticker + ".feather")
        else:
            if current and not (datetime.datetime.now().hour < 5 or (datetime.datetime.now().hour < 6 and datetime.datetime.now().minute < 30)):

                tvr = TvDatafeed(username="cs.benliu@gmail.com",password="tltShort!1")
                screener_data = feather.read_feather(r"C:\Screener\tmp\screener_data_intraday.feather")
                screener_data.set_index('Ticker', inplace = True)
                exchange = str(screener_data.loc[ticker]['Exchange'])
                df = tvr.get_hist(ticker, exchange, interval=Interval.in_1_minute, n_bars=1000, extended_session = premarket)
                df.drop('symbol', axis = 1, inplace = True)
                df.index = df.index + pd.Timedelta(hours=4)
                seconds = datetime.datetime.now().second
                bar = df.iloc[-1]
                df.drop(df.tail(1).index,inplace = True)
                if seconds > 30:
                    mult = pow((60 / seconds),.6)
                    openn = bar['open']
                    high = bar['high']
                    low = bar['low']
                    close = bar['close']
                    vol = bar['volume']
                    new_open = openn
                    new_close = close + (close - openn) * mult 
                    new_vol = vol*mult 
                    new_high = high
                    new_low = low
                    if new_close > high:
                        new_high = new_close
                    if new_close < low:
                        new_low = new_close

                    now = datetime.datetime.now()
                    new = pd.DataFrame({'datetime':[now],
                                        'open':[new_open],
                                        'high':[new_high],
                                        'low':[new_low],
                                        'close':[new_close],
                                        'volume':[new_vol]}).set_index("datetime")
                    df = pd.concat([df,new])
            else:
                df = feather.read_feather(r"" + path + "/minute/" + ticker + ".feather")
                if not premarket:
                    df = df.between_time('09:30' , '15:59')



OLD UI 4 =---------------------------------------




import PySimpleGUI as sg
import os 
import numpy
import pandas as pd
import pathlib
import mplfinance as mpf
from PIL import Image
from matplotlib import pyplot as plt
import io
import datetime
import matplotlib.ticker as mticker

from Data7 import Data as data
import time as ttime
import shutil
from time import sleep
from multiprocessing.pool import Pool


class UI:

    def loop(self,current = False):

        if os.path.exists("C:/Screener/tmp/charts"):
            shutil.rmtree("C:/Screener/tmp/charts")
        os.mkdir("C:/Screener/tmp/charts")
        self.i = 0
        self.annotation = False
        try:
            if current:
                self.setups_data =pd.read_feather(r"C:\Screener\tmp\todays_setups.feather")
                self.historical = False
    
            else:
                self.setups_data =pd.read_feather(r"C:\Screener\tmp\setups.feather")
                self.historical = True

        except:
            print('There were no setups')
            exit()

        if len(self.setups_data ) == 0: 
            print('There were no setups')
            exit()

        self.sort = False
        self.preloadamount = 20
       

        with Pool(6) as self.pool:
            self.lookup(self,"","","","","","")
            self.update(self,True,None,0)

            while True:
            
                event, values = self.window.read()
                if event == 'Next': 
                    if self.i < len(self.setups_data) - 1:
                        previ = self.i
                        self.i += 1
                        self.update(self,False,values,previ)
                        self.window.refresh()
                        self.preload(self,self.i + self.preloadamount)
    
                if event == 'Prev':
                
                    if self.i > 0:
                        previ = self.i
                        self.i -= 1
                   
                        self.update(self,False,values,previ)

                if event == 'Load':
                    red = values['input-redate']
                    if red != "":
                        self.redate(self,self.i,values['input-redate'])

                        i = self.i
                        for thing in range(4):

                            if os.path.exists(f"C:/Screener/tmp/charts/{thing + 1}{i}.png"):
                                os.remove(f"C:/Screener/tmp/charts/{thing + 1}{i}.png")
                    
                        self.preload(self,i)
               
                        self.update(self,False,values,i)
                    else:
                        timeframe = values['input-timeframe']
                        ticker = values["input-ticker"]
                        date = values["input-date"]
                        setup = values["input-setup"]
                        keyword = values["input-keyword"]
                        previ = 0
                        sortinput = values["input-trait"]
                        self.lookup(self,ticker,date,setup,keyword,sortinput,timeframe)
                        self.update(self,False,values,previ)

                if event == 'Toggle':
                    previ = self.i
                    if self.annotation:
                        try:
                            self.annotation = False
                            timeframe = values['input-timeframe']
                            ticker = values["input-ticker"]
                            date = values["input-date"]
                            setup = values["input-setup"]
                            keyword = values["input-keyword"]
                            sortinput = values["input-trait"]
                            self.lookup(self,ticker,date,setup,keyword,sortinput,timeframe)
                            self.update(self,False,values,previ)
                        except pd.errors.EmptyDataError:
                            sg.Popup('No Setups Found')
   
                    else:
                        try: 
                            self.annotation = True
                            timeframe = values['input-timeframe']
                            ticker = values["input-ticker"]
                            date = values["input-date"]
                            setup = values["input-setup"]
                            keyword = values["input-keyword"]
                            sortinput = values["input-trait"]
                            self.lookup(self,ticker,date,setup,keyword,sortinput,timeframe)
                            self.update(self,False,values,previ)
                        except pd.errors.EmptyDataError:
                            sg.Popup('No Setups Found')
    
                if event == sg.WIN_CLOSED:
                    break
            self.window.close()

    def preload(self,i):
        pool = self.pool
        if type(i) == int:
            i = [i]
      
        arglist = []
        for index in i:
            arglist.append([self.setups_data,index])
        pool.map_async(self.plot,arglist)

    def redate(self,previ,new):
        df = pd.read_feather(r"C:\Screener\tmp\setups.feather")
        index = self.setups_data.index[previ]
        ap = data.get()
        date = (self.setups_data.iat[previ,0])
        new_index = data.findex(ap,date) + int(new)
        newdate = ap.index[new_index]
        df.at[index, 'Date'] = newdate
        self.setups_data.at[index, 'Date'] = newdate
                
        df.to_feather(r"C:\Screener\tmp\setups.feather")
        

    def lookup(self,ticker,date,setup,keyword,sortinput,timeframe):
        
        print(f'searching for "{keyword}"')
        scan = pd.read_feather(r"C:\Screener\tmp\setups.feather")

        if timeframe  != "":
            scan = scan[scan['timeframe'] == timeframe]
            
        if ticker  != "":
            scan = scan[scan["Ticker"] == ticker]

        if date  != "":
            scan = scan[scan['Date'] == date]
     
        if setup  != "":
            scan = scan[scan['Setup'] == setup]
      
        if keyword  != "":
            lis = keyword.split(',')
            for keyword in lis:
                scan = scan[scan['annotation'].str.contains(keyword)]   
        else:
            scan = scan[scan['annotation'] == "" ]
            
        if sortinput != "":
            print(scan)
            idex = 0
            if sortinput == 'z':
                idex = 'Z'
            if sortinput == 'gap':
                idex = 'gap'
            if sortinput == 'adr':
                idex = 'adr'
            if sortinput == 'vol':
                idex = 'vol'
            if sortinput == '1':
                idex = '1'
            if sortinput == '2':
                idex = '2'
            if sortinput == '3':
                idex = '3'
            if sortinput == '10':
                idex = '10'
            if sortinput == 'time':
                idex = 'time'

            if idex != 0:

                scan = scan.sort_values(by=[idex], ascending=False)

            else:
                sg.Popup('Not A Trait')

        else:
            scan = scan.sample(frac=1)

        if len(scan) < 1:
            sg.Popup('No Setups Found')
        else:
            
            self.i = 0
            self.setups_data = scan
            if os.path.exists("C:/Screener/tmp/charts"):
                shutil.rmtree("C:/Screener/tmp/charts")
            os.mkdir("C:/Screener/tmp/charts")
           
            self.preload(self, list(range(self.preloadamount)))

    def plot(slist):
        
        i = slist[1]
        setups_data = slist[0]

     
        
        iss = str(i)
        
        if (os.path.exists("C:/Screener/tmp/charts/1" + iss + ".png") == False):

            print(f'preloading {i}')
               
            mc = mpf.make_marketcolors(up='g',down='r')
            s  = mpf.make_mpf_style(marketcolors=mc)
            date = (setups_data.iloc[i][0])
           
            ticker = setups_data.iloc[i][1]
            setup = setups_data.iloc[i][2]
            z= setups_data.iloc[i][3]
            tf= setups_data.iloc[i][4] 
            zs = z
            
            
            if data.isToday(date):
                if tf == 'd':
                    tf1 = 'd'
                    tf2 = 'w'
                    tf3 = 'h'
                    tf4 = '15min'
                if tf == 'h':
                    tf1 = 'h'
                    df2 = 'd'
                    df3 = '15min'
                    df4 = '1min'
                if tf == '5min':
                    tf1 = '5min'
                    tf2 = 'd'
                    tf3 = 'h'
                    tf4 = '1min'
                if tf == '1min':
                    tf1 = '1min'
                    tf2 = 'd'
                    tf3 = 'h'
                    tf4 = '5min'
            else:
                if tf == 'd':
                    tf1 = 'd'
                    tf2 = 'w'
                    tf3 = 'h'
                    tf4 = '1min'
                if tf == 'h':
                    tf1 = 'h'
                    df2 = 'd'
                    df3 = '15min'
                    df4 = '1min'
                if tf == '5min':
                    tf1 = '5min'
                    tf2 = 'd'
                    tf3 = 'h'
                    tf4 = '1min'
                if tf == '1min':
                    tf1 = '1min'
                    tf2 = 'd'
                    tf3 = 'h'
                    tf4 = '5min'

            datedaily = f"{date}"
            datehourly = f"{date} 09:00"
            dateminute = f"{date} 09:30"

            chartsize = 150
           
            ch = 50
            cd = 100
            cm = 0

            sh = 200
            sd = 150
            sm = 300

            fw = 20
            fh = 7

            fs = .8

            try:
                if 'h' in tf1:
                    c1 = ch
                    d1 = datehourly
                    s1 = sh
                elif 'min' in tf1:
                    d1 = dateminute
                    c1 = cm
                    s1 = sm
                else:
                    c1 = cd
                    d1 = datedaily
                    s1 = sd
                df1 = data.get(ticker,tf1,date)
                l1 = data.findex(df1,date) - c1
                r1 = l1 + s1
                if l1 < 0:
                    l1 = 0
                df1 = df1[l1:r1]
                string1 = "1" + iss + ".png"
                p1 = pathlib.Path("C:/Screener/tmp/charts") / string1
                if data.isToday(date):
                    fig, axlist  =  mpf.plot(df1, type='candle', volume=True, title=str(f'{ticker}   {setup}   {round(zs,2)}   {tf1}'), style=s, returnfig = True, figratio = (fw,fh), mav=(10,20),figscale=fs, panel_ratios = (5,1), tight_layout = True)#, hlines=dict(hlines=[pmPrice], alpha = .25))
                    ax = axlist[0]
                 
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                   
                    plt.savefig(p1, bbox_inches='tight')
                    
                else:
                    fig, axlist = mpf.plot(df1, type='candle', volume=True, title=str(f'{ticker}   {date}   {setup}   {round(zs,2)}   {tf1}'), style=s, returnfig = True,figratio = (fw,fh),figscale=fs, panel_ratios = (5,1), mav=(10,20), tight_layout = True,vlines=dict(vlines=[d1], alpha = .25))
                    ax = axlist[0]
                  
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                    
                    plt.savefig(p1, bbox_inches='tight')
            except:
                pass
                #print(ticker)
               
                


            try:
                if 'h' in tf2:
                    c2 = ch
                    d2 = datehourly
                    s2 = sh
                elif 'min' in tf2:
                    d2 = dateminute
                    c2 = cm
                    s2 = sm
                else:
                    d2 = datedaily
                    c2 = cd
                    s2 = sd
                df2 = data.get(ticker,tf2)
                l2 = data.findex(df2,date) - c2
                r2 = l2 + s2
                if l2 < 0:
                    l2 = 0
                df2 = df2[l2:r2]
                string2 = "2" + iss + ".png"
                p2 = pathlib.Path("C:/Screener/tmp/charts") / string2
                if data.isToday(date):
                    fig, axlist = mpf.plot(df2, type='candle', volume=True, title = str(tf2), style=s,  returnfig = True, figratio = (fw,fh), mav=(10,20),figscale=fs, panel_ratios = (5,1), tight_layout = True)#, hlines=dict(hlines=[pmPrice], alpha = .25))
                    ax = axlist[0]
                 
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                   
                    plt.savefig(p2, bbox_inches='tight')
                else:
                    fig, axlist =  mpf.plot(df2, type='candle', volume=True, title=str(tf2), style=s, returnfig = True, figratio = (fw,fh), mav=(10,20),figscale=fs, panel_ratios = (5,1), tight_layout = True,vlines=dict(vlines=[d2], alpha = .25))
                    ax = axlist[0]
                 
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                   
                    plt.savefig(p2, bbox_inches='tight')
            except:
                pass
             

            string3 = "3" + iss + ".png"
            p3 = pathlib.Path("C:/Screener/tmp/charts") / string3
            try:
                if 'h' in tf3:
                    d3 = datehourly
                    c3 = ch
                    s3 = sh
                elif 'min' in tf3:
                    d3 = dateminute
                    c3 = cm
                    s3 = sm
                else:
                    c3 = cd
                    d3 = datedaily
                    s3 = sd
                df3 = data.get(ticker,tf3)
                l3 = data.findex(df3,date) - c3
                r3 = l3 + s3
                if l3 < 0:
                    l3 = 0
                df3 = df3[l3:r3]
                
                if data.isToday(date):
                    fig, axlist = mpf.plot(df3, type='candle', volume=True, title = str(tf3),style=s,  returnfig = True, figratio =(fw,fh), mav=(10,20),figscale=fs, panel_ratios = (5,1), tight_layout = True)#, hlines=dict(hlines=[pmPrice], alpha = .25))
                    ax = axlist[0]
                    
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                   
                    plt.savefig(p3, bbox_inches='tight')
                else:
                    fig, axlist = mpf.plot(df3, type='candle', volume=True, title = str(tf3),style=s,  returnfig = True, figratio = (fw,fh), mav=(10,20),figscale=fs, panel_ratios = (5,1), tight_layout = True,vlines=dict(vlines=[d3], alpha = .25))
                    ax = axlist[0]
                   
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                   
                    plt.savefig(p3, bbox_inches='tight')
            except:
                shutil.copy(r"C:\Screener\tmp\blank.png",p3)
      


            string4 = "4" + iss + ".png"
            p4 = pathlib.Path("C:/Screener/tmp/charts") / string4
            try:
                if 'h' in tf4:
                    c4 = ch
                    d4 = datehourly
                    s4 = sh
                elif 'min' in tf4:
                    c4 = cm
                    d4 = dateminute
                    s4 = sm
                else:
                    c4 = cd
                    d4 = datedaily
                    s4 = sd
                df4 = data.get(ticker,tf4)
                l4 = data.findex(df4,date) - c4
                r4 = l4 + s4
                if l4 < 0:
                    l4 = 0
                df4 = df4[l4:r4]
                
                
                if data.isToday(date):
                    plot, axlist =  mpf.plot(df4, type='candle', volume=True, title = str(tf4),style=s, returnfig = True, figratio = (fw,fh),figscale=fs, panel_ratios = (5,1), mav=(10,20), tight_layout = True)#, hlines=dict(hlines=[pmPrice], alpha = .25))
                    ax = axlist[0]
                    
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                   
                    plt.savefig(p4, bbox_inches='tight')
                else:
                    plot, axlist = mpf.plot(df4, type='candle', volume=True, title = str(tf4),style=s, returnfig = True, figratio = (fw,fh),figscale=fs, panel_ratios = (5,1), mav=(10,20), tight_layout = True,vlines=dict(vlines=[d4], alpha = .25))
                    ax = axlist[0]
                    
                    ax.set_yscale('log')
                    ax.yaxis.set_minor_formatter(mticker.ScalarFormatter())
                   
                    plt.savefig(p4, bbox_inches='tight')
            except:
                shutil.copy(r"C:\Screener\tmp\blank.png",p4)
        
      
        
    def update(self, init,values,previ):
        image1 = None
        image2 = None
        image3 = None
        image4 = None

        gosh = 1
        start = datetime.datetime.now()
        while True:
            if (datetime.datetime.now() - start).seconds < gosh or init:
                if image1 == None:
                        try:
                            image1 = Image.open(r"C:\Screener\tmp\charts\1" + str(self.i) + ".png")
                        except:
                            pass
                if image2 == None:
                    try:
                        image2 = Image.open(r"C:\Screener\tmp\charts\2" + str(self.i) + ".png")
                    except :
                        pass
                if image3 == None:
                    try:
                        image3 = Image.open(r"C:\Screener\tmp\charts\3" + str(self.i) + ".png")
                    except:
                        pass
                if image4 == None:
                    try:
                        image4 = Image.open(r"C:\Screener\tmp\charts\4" + str(self.i) + ".png")
                    except:
                        pass

                if image1 != None and image2 != None and image3 != None and image4 != None:
                    break
            else:
                self.preload(self,self.i)
                start = datetime.datetime.now()
                print('reloading image')
                gosh = 10
                
        bio1 = io.BytesIO()
        image1.save(bio1, format="PNG")
        bio2 = io.BytesIO()
        image2.save(bio2, format="PNG")
        bio3 = io.BytesIO()
        image3.save(bio3, format="PNG")
        bio4 = io.BytesIO()
        image4.save(bio4, format="PNG")
        
        if self.historical:

            gap = str(self.setups_data.iloc[self.i][5])
            adr = str(self.setups_data.iloc[self.i][6])
            vol = str(self.setups_data.iloc[self.i][7])
            q = str(self.setups_data.iloc[self.i][8])
            one = str(self.setups_data.iloc[self.i][9])
            two = str(self.setups_data.iloc[self.i][10])
            three = str(self.setups_data.iloc[self.i][11])
            ten = str(self.setups_data.iloc[self.i][12])
            annotation = str(self.setups_data.iloc[self.i][13])
            time = str(self.setups_data.iloc[self.i][14])

            if annotation == "nan":
                annotation = ""
 
            if init:
                sg.theme('DarkGrey')
                layout = [  
                [sg.Image(bio1.getvalue(),key = '-IMAGE-'),sg.Image(bio2.getvalue(),key = '-IMAGE2-')],
                [sg.Image(bio3.getvalue(),key = '-IMAGE3-'),sg.Image(bio4.getvalue(),key = '-IMAGE4-')],
                [ (sg.Text("gap")),(sg.Text(gap, key = '-gap-')),
                (sg.Text("|   adr")),(sg.Text(adr, key = '-adr-')),
                (sg.Text("|   vol")),(sg.Text(vol, key = '-vol-')),
                (sg.Text("|   q")),(sg.Text(q, key = '-q-')),
                (sg.Text("|   1")),(sg.Text(one, key = '-one-')),
                (sg.Text("|   2")),(sg.Text(two, key = '-two-')),
                (sg.Text("|   3")),(sg.Text(three, key = '-three-')),
                (sg.Text("|   10")),(sg.Text(ten, key = '-ten-')),
                (sg.Text("|   time")),(sg.Text(time, key = '-time-'))],
                [sg.Multiline(annotation,size=(150, 5), key='annotation')],
                [(sg.Text("Timeframe")),sg.InputText(key = 'input-timeframe')],
                [(sg.Text("Ticker      ")),sg.InputText(key = 'input-ticker')],
                [(sg.Text("Date        ")),sg.InputText(key = 'input-date')],
                [(sg.Text("Setup      ")),sg.InputText(key = 'input-setup')],
                [(sg.Text("Keyword  ")),sg.InputText(key = 'input-keyword')],
                [(sg.Text("Trait        ")),sg.InputText(key = 'input-trait')],
                [(sg.Text("Redate    ")),sg.InputText(key = 'input-redate')],
                [(sg.Text((str(f"{self.i + 1} of {len(self.setups_data)}")), key = '-number-'))],
                [sg.Button('Prev'), sg.Button('Next'),sg.Button('Load')]]
                self.window = sg.Window('Screener', layout,margins = (10,10))
            else:
                df = pd.read_feather(r"C:\Screener\tmp\setups.feather")
                index = self.setups_data.index[previ]
                df.at[index, 'annotation'] = values["annotation"]
                self.setups_data.at[index, 'annotation'] = values["annotation"]   
                df.to_feather(r"C:\Screener\tmp\setups.feather")
                self.window['-number-'].update(str(f"{self.i + 1} of {len(self.setups_data)}"))
                self.window["-gap-"].update(gap)
                self.window["-adr-"].update(adr)
                self.window["-vol-"].update(vol)
                self.window["-q-"].update(q)
                self.window["-one-"].update(one)
                self.window["-two-"].update(two)
                self.window["-three-"].update(three)
                self.window["-ten-"].update(ten)
                self.window["-time-"].update(time)
                self.window["annotation"].update(annotation)
                self.window["input-redate"].update("")
                self.window["-IMAGE-"].update(data=bio1.getvalue())
                self.window["-IMAGE2-"].update(data=bio2.getvalue())
                self.window["-IMAGE3-"].update(data=bio3.getvalue())
                self.window["-IMAGE4-"].update(data=bio4.getvalue())
   
        else:
            if init:
                sg.theme('DarkGrey')
                
                layout = [  
                [sg.Image(bio1.getvalue(),key = '-IMAGE-'),sg.Image(bio2.getvalue(),key = '-IMAGE2-')],
                [sg.Image(bio3.getvalue(),key = '-IMAGE3-'),sg.Image(bio4.getvalue(),key = '-IMAGE4-')],
                [(sg.Text((str(f"{self.i + 1} of {len(self.setups_data)}")), key = '-number-'))],
                [sg.Button('Prev'), sg.Button('Next')] ]
                self.window = sg.Window('Screener', layout,margins = (10,10))
            else:
                try:

                    self.window["-IMAGE-"].update(data=bio1.getvalue())
                    self.window["-IMAGE2-"].update(data=bio2.getvalue())
                    self.window["-IMAGE3-"].update(data=bio3.getvalue())
                    self.window["-IMAGE4-"].update(data=bio4.getvalue())
                except:
                    print("image load failed")
                self.window['-number-'].update(str(f"{self.i + 1} of {len(self.setups_data)}"))
           
if __name__ == "__main__":
    UI.loop(UI,False)










UI prelaod -------------------------------------------------

                 
    
        '''


        arglist = []
        c = 0
        #tm = datetime.datetime.now()
        if init:
       # if not init:
        #    c = self.preloadbuffer

            if force == None:
                for x in range(self.preloadamount - c):
            
                    v = (x + self.i + c)
                    
                    if v < len(self.setups_data):
                        arglist.append([self.setups_data,v])
            else:
                arglist.append([self.setups_data,force])
            
            with Pool() as pool:
               
                pool.map(self.plot, arglist)
                pool.close()
                pool.join
              
        else:
            v = self.i + self.preloadamount - 1
            with Pool() as pool:
            
                process = pool.apply_async(self.plot,args = ([self.setups_data,v],))
                return(process)
                #pool.close()
            #pool.join()
            
        #print(datetime.datetime.now() - tm)





UI image loader ------------------------------------------------------


        '''
        #lasttime = ttime.time()
        image1 = None
        image2 = None
        image3 = None
        image4 = None
        while True:
           # laptime = round((ttime.time() - lasttime), 2)
            #if laptime < 5:

                
            if image1 == None:
                try:
                    image1 = Image.open(r"C:\Screener\tmp\charts\1" + str(self.i) + ".png")
                except:
                    pass
                 
            if image2 == None:
                try:
                    image2 = Image.open(r"C:\Screener\tmp\charts\2" + str(self.i) + ".png")
                except :
                    pass
            if image3 == None:
                try:
                    image3 = Image.open(r"C:\Screener\tmp\charts\3" + str(self.i) + ".png")
                except:
                    pass
            if image4 == None:
                try:
                    image4 = Image.open(r"C:\Screener\tmp\charts\4" + str(self.i) + ".png")
                except:
                    pass

            if image1 != None and image2 != None and image3 != None and image4 != None:
                break
                
        '''


OLD UI LOOKUP SORTERS -----------------------------------------------------------

if timeframe  != "":
            scanholder = pd.DataFrame()
            for k in range(len(scan)):
                if scan.iloc[k][4] == timeframe:
                    scanholder = pd.concat([scanholder,scan.iloc[[k]]])
            scan = scanholder
        if ticker  != "":
            scanholder = pd.DataFrame()
            for k in range(len(scan)):
                if scan.iloc[k][1] == ticker:
                    scanholder = pd.concat([scanholder,scan.iloc[[k]]])
            scan = scanholder
        if date  != "":
            scan = scan[scan['Date'] == date]
            '''
            scanholder = pd.DataFrame()
            for k in range(len(scan)):
                if scan.iloc[k][0] == date:
                    scanholder = pd.concat([scanholder,scan.iloc[[k]]])
            scan = scanholder
            '''
        if setup  != "":
            scan = scan[scan['Setup'] == setup]
            '''
            scanholder = pd.DataFrame()
            for k in range(len(scan)):
                if scan.iloc[k][2] == setup:
                    scanholder = pd.concat([scanholder,scan.iloc[[k]]])
            scan = scanholder
            '''
        if keyword  != "":
            lis = keyword.split(',')
            for keyword in lis:
                scan = scan[scan['annotation'].str.contains(keyword)]
            '''
            scanholder = pd.DataFrame()
            for k in range(len(scan)):
                if  str(keyword) in str(scan.iloc[k][13]) :
                    scanholder = pd.concat([scanholder,scan.iloc[[k]]])
            scan = scanholder
            '''
                
        else:
            scan = scan[scan['annotation'] == "" ]
            '''
        #if self.annotation:
            scanholder = pd.DataFrame()
            for k in range(len(scan)):
                #print(f'"{scan.iat[k,13]}"')
                val = scan.iat[k,13]
                
                if  (val !=  val or val == ""): # == "" or scan.iloc[k][12] == None:
                    
                    #scan = scan.drop(index = k)
                    #print(scan)
                    scanholder = pd.concat([scanholder,scan.iloc[[k]]])
            scan = scanholder
        '''





        
'''
            if event == 'Sort' and False:

                if self.sort:
                    self.sort = False
                else:
                    self.sort = True
                ticker = values["input-ticker"]
                date = values["input-date"]
                setup = values["input-setup"]
                keyword = values["input-keyword"]
                
                previ = 0
              
                sortinput = values["input-trait"]
                self.lookup(self,ticker,date,setup,keyword,sortinput)
                self.update(self,False,values,previ)
              '''  

NOT REALLY OLD FLAG ------------------------------------------------------------------
def Flag(df,currentday, tf, ticker, path):

		
		lmax = 100
		lmin = 7
		mal = 5

		upper_stdev_filter = 1.5
		lower_stdev_filter = .75
		upper_stdev_filter2 = 1.5

		lower_stdev_filter2 = 1
		mal2 = 2
		coef = 0.01
		swings = np.empty([0,3])
		slope = 0
		prevma = []
		end = False
		def MA(df,i,l):
			ma = []
			for j in range(l):
				ma.append(df.iat[i-j,3])
				return statistics.mean(ma)
		ma = MA(df,currentday - 1,mal)
		i = 2
		while True:
			prevma = MA(df,currentday - i,mal)
			if slope == 1 and ma < prevma:
				slope = -1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,0]],axis = 0)
				if end:
					break
			elif slope == -1 and ma > prevma:
				slope = 1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,1]],axis = 0)
				if end:
					break
			elif slope == 0:
				if ma > prevma:
					slope = 1
				else:
					slope = -1

			if i >= lmax:
				end = True
			ma = prevma
			i += 1

		lval = 0
		l = 0


		for i in range(len(swings)-1):


			val = abs(swings[i,0]/swings[i+1,0] - 1) * (1 - coef * swings[i,1])
			if val > lval:
				lval = val
				move_size = abs(swings[i,0] - swings[i+1,0])
				l = swings[i,1] + int(mal/2)
		slope = 0
		swings = np.empty([0,3])
		ma = MA(df,currentday - 1,mal)
		i = 2
		end = False
		while True:
	
			prevma = MA(df,currentday - i,mal2)
			if slope == 1 and ma < prevma:
				slope = -1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,0]],axis = 0)
				add = df.iat[currentday-i,2]
				swings = np.append(swings,[[add,i,0]],axis = 0)
				if end:
					break
			elif slope == -1 and ma > prevma:
				slope = 1
				add = df.iat[currentday-i,3]
				swings = np.append(swings,[[add,i,1]],axis = 0)
				add = df.iat[currentday-i,1]
				swings = np.append(swings,[[add,i,1]],axis = 0)
				if end:
					break
			elif slope == 0:
				if ma > prevma:
					slope = 1
				else:
					slope = -1
			if i >= lmax:
				end = True
			ma = prevma
			i += 1
		if l >= lmin and l < lmax:
			i = 0
			while True:
				if swings[i,1] > l:
					swings = swings[0:i]
					break
				i += 1
			n = len(swings)
			xh = np.empty([0,1])
			yh = np.empty(0)
			xl = np.empty([0,1])
			yl = np.empty(0)
			all_swings = []
			for i in range(n):
				high = swings[i,2]
				if high == 1:
					xh = np.append(xh,[[swings[i,1]]],axis = 0)
					yh = np.append(yh,swings[i,0])
				else:
					xl = np.append(xl,[[swings[i,1]]],axis = 0)
					yl = np.append(yl,swings[i,0])
				all_swings.append(swings[i,0])
			stdev = np.std(yl)
			mean = np.mean(yl)
			x = np.empty(0)
			y = np.empty(0)
			for i in range(len(yl) -1,-1,-1):
				z = (yl[i] - mean)/stdev
				if z < -upper_stdev_filter2 or z > lower_stdev_filter2:
					yl = np.delete(yl,i)
					xl = np.delete(xl,i,axis = 0)
			stdev = np.std(yh)
			mean = np.mean(yh)
			x = np.empty(0)
			y = np.empty(0)
			for i in range(len(yh) -1,-1,-1):
				z = (yh[i] - mean)/stdev
				if z > upper_stdev_filter or z < -lower_stdev_filter:
					yh = np.delete(yh,i)
					xh = np.delete(xh,i,axis = 0)
			modelh = LinearRegression().fit(xh, yh)
			bh = modelh.intercept_
			mh = modelh.coef_
			modell = LinearRegression().fit(xl, yl)
			bl = modell.intercept_
			ml = modell.coef_

			#calc traits
			tightening = mh - ml
			tightness = bh - bl
			higher_lows = -ml
			z = move_size / tightness
			atr= []
			adr_l = int(l)
			for j in range(adr_l): 
				high = df.iat[currentday-j-1,1]
				low = df.iat[currentday-j-1,2]
				val = (high - low ) 
				atr.append(val)
			atr = statistics.mean(atr)  
			oc = (df.iat[currentday - 1,0] + df.iat[currentday - 1,3])/2
			avg_slope = ((abs(ml) + abs(mh))/2)
			high = df.iat[currentday,1]
			low = df.iat[currentday,2]
			prev_close =df.iat[currentday-1,3]
			if (bh > bl and 
			z >3  and
			bh + mh*l > bl + ml*l 
			and oc < bh): 
				if prev_close < bh and prev_close > bl:
					val = avg_slope / atr
					if val < .1:
						val2 = tightening/atr
						if val2 > 0:
							log.log(df,currentday, tf, ticker, z, path, 'Flag')  


WEEKLY FLAG --------------------------------------------------------------------------


	def weeklyFlag(df,currentday, tf, ticker, path):
		pmPrice = df.iat[currentday,0]
		
		zfilter = 5
		z2filter = -100
		lmin = 20
		lmax = 50
		rsil = 20
		zl = 20
		rsi_filter = 30
		

		
			
			
		rsimax = 0
		for j in range(lmax):
				
			gains = []
			losses = []
					
					
			for k in range(rsil):
				change = (df.iat[currentday-k-j-1,3]/df.iat[currentday-k-j-2,3]) - 1
				if change > 0:
					gains.append(change)
				else:
					losses.append(-change)


			RS = (sum(gains)/rsil) / (sum(losses)/rsil)
			rsi = abs((100 - (100 / (1 + RS))) - 50)
			   
			if rsi > rsimax:
				rsimax = rsi
				l = j - 1
				
		  
				
		gaindata = []
		flagdata = []
			
		halfdata = []
				
		if l > lmin and l < lmax - 2 and rsimax > rsi_filter:
			for j in range(l * 2):
				ma3 = []
				for k in range(3):

					ma3.append(df.iat[currentday-j-k-1,3])
				ma3 = statistics.mean(ma3)
						  
				if j < int(l/2):
					halfdata.append(ma3)

				if j >=l:
					gaindata.append(ma3)
				else:

					flagdata.append(ma3)
					
			gain = max(gaindata) - min(gaindata)
			flag = max(flagdata) - min(flagdata)
			   
			halfflag = max(halfdata) - min(halfdata) 

			value = gain - flag
				

			zdata = []
			
			for i in range(zl):
				pushvalue = df.iat[currentday-i-1,1] - df.iat[currentday-i-1,2]
				zdata.append(pushvalue)

			z = (value - statistics.mean(zdata))/statistics.stdev(zdata)
			z2 =  -((halfflag - statistics.mean(zdata))/statistics.stdev(zdata))
			 
			if z > zfilter and z2 > z2filter:
					
				log.log(df,currentday, tf, ticker, z, path, 'WWFlg')  

OLD PIVOT -------------------------------------------------------------------------------------------------------------------------------------------------------------------


       
        lowergapzfilter = 1.5
        lowergapzfilter2 = 1.5

        pmPrice = df.iat[currentday,0]
       
        
        prevClose = df.iat[currentday-1,3]
        zgaps = []
        for i in range(15):
            n = 14-i
            gapvalue = abs((df.iat[currentday-n-1,0]/df.iat[currentday-n-2,3]) - 1)
            zgaps.append(gapvalue)
            
        todayGapValue = (pmPrice/prevClose)-1
        gapz = (abs(todayGapValue)-statistics.mean(zgaps))/statistics.stdev(zgaps)
        lastCloses = 0
        for c in range(4): 
            lastCloses = lastCloses + df.iat[currentday-c-1,3]
                
        ma3 = (lastCloses/4)
        close1 = df.iat[currentday-1,3]
        close2 = df.iat[currentday-2,3]
        open1 = df.iat[currentday-1,0]
        open2 = df.iat[currentday-2,0]
        low1 = df.iat[currentday-1,2]
        high1 = df.iat[currentday-1,1]
        z = gapz

         if gapz > lowergapzfilter and close1 < ma3  and close1 < close2 and close2 < open2 and close1 < open1 and open1 < close2 and pmPrice > high1 :
                
                
           log.log(df,currentday, tf, ticker, z, path, 'Pivot')   

        if gapz > lowergapzfilter2 and close1 > ma3  and close1 > close2 and close2 > open2 and close1 > open1 and open1 > close2 and pmPrice < low1:

            log.log(df,currentday, tf, ticker, z, path, 'Pivot') 




OLD FLAG DETECTION---------------------------------------------------------------------------------------------------------------------------------------------------------

pmPrice = df.iat[currentday,0]
       
        
        #if test:
           # zfilter = 4
       # else:
        zfilter = 8


        z2filter = .25
        lmin = 5
        lmax = 20
        rsil = 20
        zl = 20
        rsi_filter = 25
        todayl = 0
        currentvalue = 0

       
            
        rsimax = 0
        for j in range(lmax):
                
            gains = []
            losses = []
                    
                    
            for k in range(rsil):
                
                change = (df.iat[currentday-k-j-1,3]/df.iat[currentday-k-j-2,3]) - 1
                
                    
                if change > 0:
                    gains.append(change)
                else:
                    losses.append(-change)


            RS = (sum(gains)/rsil) / (sum(losses)/rsil)
            rsi = abs((100 - (100 / (1 + RS))) - 50)
               
            if rsi > rsimax:
                rsimax = rsi
                l = j - 1
                
          
                
        gaindata = []
        flagdata = []
            
        halfdata = []
                
        if l > lmin and l < lmax - 2 and rsimax > rsi_filter:
            for j in range(l * 2):
                ma3 = []
                for k in range(3):

                    ma3.append(df.iat[currentday-j-k-1,3])
                ma3 = statistics.mean(ma3)
                          
                if j < int(l/2):
                    halfdata.append(ma3)

                if j >=l:
                    gaindata.append(ma3)
                else:

                    flagdata.append(ma3)
                    
            gain = max(gaindata) - min(gaindata)
            flag = max(flagdata) - min(flagdata)
               
            halfflag = max(halfdata) - min(halfdata) 

            value = gain - flag
                

            zdata = []
            
            for i in range(zl):
                pushvalue = df.iat[currentday-i-1,1] - df.iat[currentday-i-1,2]
                zdata.append(pushvalue)

            z = (value - statistics.mean(zdata))/statistics.stdev(zdata)
            z2 =  -((halfflag - statistics.mean(zdata))/statistics.stdev(zdata))
             
            
            if z > zfilter and z2 > z2filter:
                    
                log.log(df,currentday, tf, ticker, z, path, 'Flag')  

OLD Prgoress-----------------------------------------------------------------------------------------------------------


def progress(size = None):
        
        if size == None:
            f = open('progress.txt','r')
            read = f.readlines()
            
            size = int(read[0])
            num = int(read[1])
            
            num += 1 

            f = open('progress.txt','w')
            f.writelines(str(f'{size} \n {num}') )

            
            p = round((num / size)*100 , 3)
            print(f'{p}%' , end='\r')
        else:
            f = open('progress.txt','w')
            f.writelines(str(f'{size} \n 0') )

OLD IDSCORD MESSAGE MAKER --------------------------------------------------------------------------------------------------------------------------------

#Log.sendDiscordEmbedIntraday(ticker + f" Open of 1m:{openCandlePrice} >> Current: {currPrice} ▲ {changePrice} ({change}%)", f"Intraday % Gaining Setup, Volume: {volume}, RelVol: {relativeVolAtTime}x, MCap: ${marketCapText}B")
        
        
        #discordintraday.post(file={"test": open('C:\Screener\tmp\test.png', "rb")})

        if False:
            openCandlePrice = float(setup_df.iloc[len(setup_df)-1][1])
            changePrice = round(float(currPrice - openCandlePrice), 2)
            change = round(screenbar["Change 1m, %"], 2)
            dayChange = round(screenbar['Change %'], 2)
            #changeFromOpen = round(screenbar['Change from Open'], 2)
            #openValue = screenbar['Open']
            currPrice = screenbar['Price']
            volume = screenbar['Volume']
            tick = screenbar['Ticker']
            pmChange = screenbar['Pre-market Change']
            currPrice = screenbar['Price']
            volume = screenbar['Volume']
            dolVol = screenbar['Volume*Price']
            marketCap = round(screenbar['Market Capitalization'], 1)
            marketCapText = round((marketCap / 1000000000), 2)
            relativeVolAtTime = round(screenbar['Relative Volume at Time'], 1)
            gapValuePercent = 0
            prevClose = 0
            pmPrice = 0
            prevClose = currPrice
            pmPrice = round((prevClose + pmChange), 2)
            gapValuePercent = round(((pmPrice/prevClose) - 1)*100, 2)
            lengthDf = len(setup_df)
            setup_df = setup_df[lengthDf - 80:]

        if(type == "Pop") and False:
            openCandlePrice = float(setup_df.iloc[len(setup_df)-1][1])
            changePrice = round(float(currPrice - openCandlePrice), 2)
            mpf.plot(setup_df, type='candle', mav=(10, 20), volume=True, title=tick, style=s, savefig=ourpath)
            log.sendDiscordEmbedIntraday(tick + f" Open of 1m:{openCandlePrice} >> Current: {currPrice} ▲ {changePrice} ({change}%)", f"Intraday % Gaining Setup, Volume: {volume}, RelVol: {relativeVolAtTime}x, MCap: ${marketCapText}B")
            log.sendDiscordIntradayPost('tmp/test.png')

        if(type == "Gainer") and False:
            openCandlePrice = float(setup_df.iloc[len(setup_df)-1][1])
            changePrice = round(float(currPrice - openCandlePrice), 2)
            mpf.plot(setup_df, type='candle', mav=(10, 20), volume=True, title=tick, style=s, savefig=ourpath)
            log.sendDiscordEmbedGainers(tick + f" PC:{prevClose} >> {currPrice} ▲ {currPrice} ({dayChange}%)", f"Top Gainer, Volume: {volume}, RelVol: {relativeVolAtTime}x, MCap: ${marketCapText}B")
            log.sendDiscordGainersPost('tmp/test.png')


OLDFINDEX -------------------------------------------
def findexold(df,dt):
        
        try:

            #if not type(dt) == datetime.date:
         #      dt = dt.date()

            x = (df.iloc[-1]['datetime'].date() - df.iloc[0]['datetime'].date()).days

            y = len(df)
            halfdate = df.iloc[int(y/2)]['datetime'].date()
            slope = y/x


            delta = (dt - halfdate).days + x/2
            

            print(delta)

            correction = 1.02
            estimate = int(correction*(delta*slope))

            i = estimate
            if i > y - 1:
                i = y - 1

           
            print(df.iloc[i]['datetime'].date())
            print( ((df.iloc[i]['datetime'].date() - dt).days)/x)

            k = 0

            

            while df.iloc[i]['datetime'].date() < dt:
                i += 1
                k += 1



            while True:

                if df.iloc[i]['datetime'].date() > dt:
                    i -= 1
                   
                else:
                    if df.iloc[i]['datetime'].time() > df.iloc[i-1]['datetime'].time():
                        i -= 1
                        
                    else:
                        break

            
         

            return i

        except TimeoutError:
            pass

       
   
    #print(df)
        #for i in range(len(df)):
            #print(f"{datetime} , {df.index[i]}")
            #if datetime < df.index[i]:
               # return i - 1 







MOVER--------------------------------------------------------------------------------------------


    def Mover(data_daily, currentday,pmPrice,screenbar, dateToSearch):
      

        zfilter = 3
        l2 = 10
        l = 100 
        q = deque([])
        z = []
        try: 
            prevClose = data_daily.iloc[currentday-1][4]
            for i in range(l + l2):
                n = l-i - 1
                q.append(data_daily.iloc[currentday-1][4])
                if len(q) >= l2:
                    ma1 = statistics.mean(q)
                    
                    if i >= l2:
                        value = abs(ma2/ma1 - 1)
                        z.append(value)
                    
                    ma2 = ma1
                    q.popleft()
            z = (value - statistics.mean(z))/statistics.stdev(z)
            if z > zfilter:
                
                
                log.daily(screenbar,z,"Mover", dateToSearch,pmPrice) 
           
        except IndexError:
           print(f" did not exist at the date " )
        except TimeoutError:
            print("Timeout caught")
        except FileNotFoundError:
            print(" does not have a file")




SCREEN------------------------------------------------------------------------------------------------------------------

user = 'cs.benliu@gmail.com'
password = 'tltShort!1'
options = Options()
options.binary_location = r"C:\Program Files\Mozilla Firefox\firefox.exe"
user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:87.0) Gecko/20100101 Firefox/87.0'
FireFoxDriverPath = os.path.join(os.getcwd(), 'Drivers', 'geckodriver.exe')
FireFoxProfile = webdriver.FirefoxProfile()
FireFoxProfile.set_preference("General.useragent.override", user_agent)
browser = webdriver.Firefox(options=options, executable_path=FireFoxDriverPath)
browser.implicitly_wait(7)
browser.maximize_window()
url = "https://www.tradingview.com/screener/"
browser.get(url)
mc = mpf.make_marketcolors(up='g',down='r')
s  = mpf.make_mpf_style(marketcolors=mc)
time.sleep(2)
element_tab = browser.find_element(By.XPATH, '//div[@data-set="performance"]')
try:
    element_tab.click()
except ElementNotInteractableException:
    print('test')

time.sleep(0.5)

element_tab = browser.find_element(By.XPATH, '//div[@data-set="overview"]')
try:
    element_tab.click()
except ElementNotInteractableException:
    print('test')

#Logging into trading view
login_page = browser.find_element(By.XPATH, '//button[@aria-label="Open user menu"]')
login_page.click()
time.sleep(0.25)
login_page = browser.find_element(By.XPATH, '//button[@data-name="header-user-menu-sign-in"]')
login_page.click()
time.sleep(0.25)
login_page = browser.find_element(By.XPATH, '//span[@class="tv-signin-dialog__social tv-signin-dialog__toggle-email js-show-email"]')
login_page.click()
username = browser.find_element(By.XPATH, '//input[@name="username"]')
username.send_keys("cs.benliu@gmail.com")
time.sleep(0.5)
password = browser.find_element(By.XPATH, '//input[@name="password"]')
password.send_keys("tltShort!1")
time.sleep(0.5)
login_button = browser.find_element(By.XPATH, '//button[@class="tv-button tv-button--size_large tv-button--primary tv-button--loader"]')
login_button.click()
time.sleep(1)
print(f'Scraping {url}...')
time.sleep(10)
print('wait over')

try:

    #setting default scanner settings
    browser.find_element(By.XPATH, '//div[@data-name="screener-field-sets"]').click()
    time.sleep(0.1)
    browser.find_element(By.XPATH, '//div[@data-set="overview"]').click()

    #seting filters
    filter_tab = browser.find_element(By.XPATH, '//div[@class="tv-screener-sticky-header-wrapper__fields-button-wrap"]')
    try:
        filter_tab.click()
    except ElementNotInteractableException:
        print('test')
    time.sleep(0.5)
    #Setting up the TV screener parameters
    tab1 = browser.find_element(By.XPATH, '//label[@data-field="earnings_per_share_basic_ttm"]')
    tab2 = browser.find_element(By.XPATH, '//label[@data-field="number_of_employees"]')
    tab3 = browser.find_element(By.XPATH, '//label[@data-field="sector"]')
    tab4 = browser.find_element(By.XPATH, '//label[@data-field="Recommend.All"]')
    tab6 = browser.find_element(By.XPATH, '//label[@data-field="price_earnings_ttm"]')
    tab7 = browser.find_element(By.XPATH, '//label[@data-field="relative_volume_intraday.5"]')
    tab8 = browser.find_element(By.XPATH, '//label[@data-field="change.1"]')
    tab9 = browser.find_element(By.XPATH, '//label[@data-field="change.5"]')
    tab10 = browser.find_element(By.XPATH, '//label[@data-field="change_from_open"]')
    tab11 = browser.find_element(By.XPATH, '//label[@data-field="exchange"]')
    tab12 = browser.find_element(By.XPATH, '//label[@data-field="premarket_change_abs"]')
    tab13 = browser.find_element(By.XPATH, '//label[@data-field="open"]')
    tab14 = browser.find_element(By.XPATH, '//label[@data-field="change_from_open_abs"]')
    tab15 = browser.find_element(By.XPATH, '//label[@data-field="change_from_open"]')
    tab1.click()
    tab2.click()
    tab3.click()
    tab4.click()
    tab6.click()
    tab7.click()
    tab8.click()
    tab9.click()
    tab10.click()
    tab11.click()
    tab12.click()
    tab13.click()
    tab14.click()
    tab15.click()
    time.sleep(0.5) 
    browser.find_element(By.XPATH, '//div[@data-name="screener-filter-sets"]').click()
    time.sleep(0.25)
    browser.find_element(By.XPATH, '//span[@class="js-filter-set-name"]').click()
    time.sleep(0.25)
    sortRVol = browser.find_element(By.XPATH, '//div[@data-field="change.1"]')
    sortRVol.click()
    count = 0
    tv = TvDatafeed(username=user,password=password)
    listTickersBurst = []
    listTickersGainers = []
    counter = 0
    while(True):



old EP 
 data_daily = tv.get_hist(tick, exchange, n_bars=100) # get 20 past daily candles
                print(data_daily.head(1))
                length = len(data_daily)
                gaps = []
                pmPrice = data_daily.iloc[length-1][4] + pmChange
                prevClose = data_daily.iloc[length-1][4]
                todayGapValue = round(((pmPrice/prevClose)-1), 2)
                for j in range(20): 
                        gaps.append((data_daily.iloc[length-1-j][1]/data_daily.iloc[length-2-j][4])-1)

                z = (todayGapValue-statistics.mean(gaps))/statistics.stdev(gaps)

                if(z < -5):
                    z = round(z, 3)
                    ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                    todayGapValuePercent = todayGapValue*100;
                    mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, title=tick, hlines=dict(hlines=[pmPrice], linestyle="-."), style=s, savefig=ourpath)
                    sendDiscordEmbed(tick + f" {prevClose} >> {pmPrice} ▼ {pmChange} ({todayGapValuePercent}%)", f"NEP Setup, Z-Score: {z}")
                    discord.post(file={"test": open("tmp/test.png", "rb")})
                if(z > 5):
                    z = round(z, 3)
                    ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                    todayGapValuePercent = todayGapValue*100;
                    mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, title=tick, hlines=dict(hlines=[pmPrice], linestyle="-."), style=s, savefig=ourpath)
                    sendDiscordEmbed(tick + f" {prevClose} >> {pmPrice} ▲ {pmChange} ({todayGapValuePercent}%)", f"EP Setup, Z-Score: {z}")
                    discord.post(file={"test": open("tmp/test.png", "rb")})

                    else:
                try: 
                    data_daily_full = pd.read_csv(f"D:/Screener/data_csvs/{tick}_data.csv")
                    indexOfDay = findIndex(data_daily_full, dateToSearch)
                    data_daily = data_daily_full
                    if(indexOfDay != 99999):
                        data_daily = data_daily_full[(indexOfDay - leftBuffer):(indexOfDay + 50)]
                        data_daily['Datetime'] = pd.to_datetime(data_daily['datetime'])
                        data_daily = data_daily.set_index('Datetime')
                        length = len(data_daily)
                        gaps = []
                        data_daily = data_daily.drop(['datetime'], axis=1)
                        tdyOpen = data_daily.iloc[length-50][1]
                        prevClose = data_daily.iloc[length-51][4]
                        todayGapValue = round(((tdyOpen/prevClose)-1), 2)  
                        for j in range(20): 
                            gaps.append((data_daily.iloc[length-51-j][1]/data_daily.iloc[length-52-j][4])-1)
                        z = (todayGapValue-statistics.mean(gaps))/statistics.stdev(gaps)
                        if(z < -4):
                            z = round(z, 3)
                            ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                            todayGapValuePercent = todayGapValue*100;
                            mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, vlines=dict(vlines=[dateToSearch],linewidths=(1), alpha=0.25), title=tick, style=s, savefig=ourpath)
                            sendDiscordEmbed(tick, f"NEP Setup, Date: {dateToSearch}, Z-Score: {z}")
                            discord.post(file={"test": open("tmp/test.png", "rb")})
                        if(z > 4):
                            z = round(z, 3)
                            ourpath = pathlib.Path("C:/Screener/tmp") / "test.png"
                            todayGapValuePercent = todayGapValue*100;
                            mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, vlines=dict(vlines=[dateToSearch],linewidths=(1), alpha=0.25), title=tick, style=s, savefig=ourpath)
                            sendDiscordEmbed(tick, f"EP Setup, Date: {dateToSearch}, Z-Score: {z}")
                            discord.post(file={"test": open("tmp/test.png", "rb")})  
                except IndexError:
                    print(tick + " did not exist at the date " + dateToSearch)
                except TimeoutError:
                    print("Timeout caught")
                except FileNotFoundError:
                    print(tick + " does not have a file")












# tv-data-table

    time.sleep(2)
    element_tab = browser.find_element(By.XPATH, '//div[@data-set="performance"]')
    try:
        element_tab.click()
    except ElementNotInteractableException:
        print('test')

    time.sleep(0.5)

    element_tab = browser.find_element(By.XPATH, '//div[@data-set="overview"]')
    try:
        element_tab.click()
    except ElementNotInteractableException:
        print('test')

    #Logging into trading view
    login_page = browser.find_element(By.XPATH, '//button[@aria-label="Open user menu"]')
    login_page.click()
    time.sleep(0.25)
    login_page = browser.find_element(By.XPATH, '//button[@data-name="header-user-menu-sign-in"]')
    login_page.click()
    time.sleep(0.25)
    login_page = browser.find_element(By.XPATH, '//span[@class="tv-signin-dialog__social tv-signin-dialog__toggle-email js-show-email"]')
    login_page.click()
    username = browser.find_element(By.XPATH, '//input[@name="username"]')
    username.send_keys("cs.benliu@gmail.com")
    time.sleep(0.5)
    password = browser.find_element(By.XPATH, '//input[@name="password"]')
    password.send_keys("tltShort!1")
    time.sleep(0.5)
    login_button = browser.find_element(By.XPATH, '//button[@class="tv-button tv-button--size_large tv-button--primary tv-button--loader"]')
    login_button.click()
    time.sleep(1)


     #Loop stocks in screen
    for i in range(numTickers):
        tick = str(screener_data.iloc[i]['Ticker'])
        exchange = str(screener_data.iloc[i]['Exchange'])
        data_minute = tv.get_hist(tick, exchange, interval=Interval.in_1_minute, n_bars=350) #get the most recent candle of pre market
        data_daily = tv.get_hist(tick, exchange, n_bars=21) # get 20 past daily candles
        data_daily_100 = tv.get_hist(tick, exchange, n_bars=70)
        length = len(data_daily)
        gaps = []
        todayGapValue = (data_daily.iloc[length-1][1]/data_daily.iloc[length-2][4])-1
        for i in range(length): 
            if i > 0:
                if i < 20: 
                    gaps.append((data_daily.iloc[i][1]/data_daily.iloc[i-1][4])-1)


        z = (todayGapValue-statistics.mean(gaps))/statistics.stdev(gaps)


        Z SCORE GAP CHECK ------------------------------------------------------------------------------------------

        # MR Check   
        if(dolVol > 1000000 and volume>150000 and currPrice > 2 and pmChange != 0 and math.isnan(pmChange) != True):
            data_daily = tv.get_hist(tick, exchange, n_bars=70) # get 20 past daily candles
            print(data_daily.head(1))
            length = len(data_daily)
            pmPrice = data_daily.iloc[length-1][4] + pmChange
            prevClose = data_daily.iloc[length-1][4]
            todayGapValue = round(((pmPrice/prevClose)-1), 2)
            data = [] # 15 length
            gaps = [] # 30 length
            changedata = [] # 30 length
            #creating data array
            val = 0
            for i in range(15): 
                num = 14-i 
                lastCloses = 0
                for c in range(4): 
                    lastCloses = lastCloses + data_daily.iloc[length-1-c-num][4]
                fourSMA = round((lastCloses/4), 2)
                if(num == 0):
                    value = (fourSMA/pmPrice)-1
                    data.append(value)
                    val = value
                else:
                    value = (fourSMA/data_daily.iloc[length-1-num][1])
                    data.append(value)
            #creating gaps and changedata array
            chng = 0
            gp = 0
            gpo1 = 0
            for k in range(30):
                n = 29-k 
                if(n == 0):
                    gap = abs((pmPrice/prevClose) - 1)
                    gp = gap
                    changedat = abs((data_daily.iloc[length-1][4]/data_daily.iloc[length-1][1]) - 1)
                    chng = changedat
                    gaps.append(gap)
                    changedata.append(changedat)
                else:
                    gap = abs((data_daily.iloc[length-n][1]/data_daily.iloc[length-1-n][4]) - 1)
                    changedat = abs((data_daily.iloc[length-1-n][4]/data_daily.iloc[length-1-n][1]) - 1)
                    changedata.append(changedat)
                    gaps.append(gap)
                if(n == 1):
                    gap = abs(data_daily.iloc[length-1][1]/data_daily.iloc[length-2][4])
                    gpo1 = (gap - statistics.mean(gaps))/statistics.mean(gaps)

            z = (val - statistics.mean(data))/statistics.stdev(data)
            changez = (chng - statistics.mean(changedata))/statistics.stdev(changedata)
            gapz = (gp - statistics.mean(gaps))/statistics.stdev(gaps)
            
            zfilter = 1
            gapzfilter0 = 8
            gapzfilter1 = 4
            changezfilter = 4
            print(f"z is = {z}, gapz is {gapz}")
            if (gpo1 < gapzfilter1 and gapz < gapzfilter0 and changez < changezfilter and z > zfilter and value > 0):
                z = round(z, 3)
                ourpath = pathlib.Path("D:/Screener/tvdatafeed/tmp") / "test.png"
                todayGapValuePercent = todayGapValue*100;
                mpf.plot(data_daily, type='candle', mav=(10, 20), volume=True, title=tick, hlines=dict(hlines=[pmPrice], linestyle="-."), style=s, savefig=ourpath)
                sendDiscordEmbed(tick + f" {prevClose} >> {pmPrice} ▲ {pmChange} ({todayGapValuePercent}%)", f"MR Setup, Z-Score: {z}")
                discord.post(file={"test": open("tmp/test.png", "rb")})


